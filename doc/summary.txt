


cookie值修改后，之前设置的maxAge会失效；
setMaxage（）如果设置为负值-1的话，则为浏览器进程Cookie(内存中保存)（jsessionid即如此），关闭浏览器就失效；如果设置为0，则立即删除该Cookie。


常量在编译的时候就已经作为常量赋值了，不会创建新的对象;变量又被称为句柄引用

"javascript:submit();"可以防止<a>函数执行完跳转回页顶的情况；
<a href="###">使页面不会重新跳转
<a href="javascript:submit();">用href跳转函数不能传递参数this;


transparent ：背景全透明;

null(Object)和undefined(Undefined)在使用上是等价的
		
		
遍历结果是Object数组集合
for (Object object : Collection) {
            Object [] obj=(Object[]) object;
            System.out.println(obj[0]+"\t"+obj[1]+"\t"+obj[2]);
        }
			
		
项目中tomcat启动了，但是访问80端口出现404，配置tomcat，修改server path 和Deploy path（前提是清空tomcat目录下的项目才能够进行修改）（webapp需要含有tomcat的初始项目文件）；


正则表达式匹配（功能模块）：   Pattern p = Pattern.compile(“正则表达式”);
                                       如（<(S*?)[^>]*>.*?|<.*? /><(S*?)[^>]*>.*?|<.*? />|[|&;$%@'\"<>()+,=\n\r\\\\]）（“\\\\”与下同理）
			Matcher m = p.matcher(“要处理的字符串”);
			String str = m.replaceAll("");
 []中的字符选择表示匹配的字符只能在该范围内   ==》同时满足多个条件^(?=.*[a-zA-Z])(?=.*[0-9])(?=.*[!@#$%^&])[0-9a-zA-Z!@#$%^&]{10,20}$    

StringEscapeUtils：字符串转义工具
StringEscapeUtils.unescapeHtml（保持对前台传过来的数据不做转义，如将html标签<p>转义成&lt;p&gt;）
使用注意对于前台的数据“\r\n”,对于java不能单独存在的自如如“\”等后台会自动转义成“\\r\\n”存储，读取输出时就会为纯字符串“\r\n”；
而对于"\'\""如果不被转义，存储格式就是“\'\"”传到前台就是" '" ";
总结：字符的输出形式取决于后台的存储格式，对字符的操作取决于底层的存储；
		

replace和replaceall的区别：    replace的参数是char和CharSequence,既可以支持字符替换，也可以支持字符串替换。
（两者都可以替换所有字符串） replaceall参数是regex, replacement，regex表示是正则表达式。


		
运用forward方法只能重定向到同一个Web应用程序中的一个资源	
redirect如果重定向到外部应用只有通过GET提交方式传递数据，如果是重定向到应用自己内部的其它地址，则还可以利用session实现数据传递。	

通过redirect返回String类型跳转，控制器用@Controller注解即可
或者将字符串redirect:url拼接字符串封装到ModelAndView中；（forward同理）；

Spring MVC中有RedirectAttributes类专门用于重定向之后还能带参数跳转的的工具类。
他有两种带参的方式：
第一种：
redirectAttributes.addAttributie("prama",value); 这种方法相当于在重定向链接地址追加传递的参数		
第二种：
redirectAttributes.addFlashAttributie("prama",value); 这种方法是隐藏了参数，链接地址上不直接暴露，但是能且只能在重定向的 “页面” 获取prama参数值。其原理就是放到session中，session在跳到页面后马上移除对象。如果是重定向一个controller中是获取不到该prama属性值的。
除非在controller中用(@RequestPrama(value = "prama")String prama)注解，
或者利用httpServletRequest ：FlashMap flashmap = RequestContextUtils.getOutputFlashMap(request); 	（flashMap就是一个存取数据的map，将数据存储在session中）
              （同上）FlashMap flashmap = ((FlashMap)(request.getAttribute(DispatcherServlet.OUTPUT_FLASH_MAP_ATTRIBUTE)));		
		
通过spring提供的RequestContextHolder在非contrller层获取request和response对象
                HttpServletRequest request = ((ServletRequestAttributes)RequestContextHolder.getRequestAttributes()).getRequest();
	HttpServletResponse response = ((ServletRequestAttributes)RequestContextHolder.getRequestAttributes()).getResponse();
	HttpServletResponse response = ((ServletWebRequest)RequestContextHolder.getRequestAttributes()).getResponse();
	ServletContext context = ContextLoader.getCurrentWebApplicationContext().getServletContext();
		
springboot日志切面：46. Spring Boot中使用AOP统一处理Web请求日志（林祥纤）

window.location.Reload()（ history.go(0)）：
刷新方法默认从已缓存页面返回数据，如果有数据提交的话，会提示是否提交的；
window.location.href：被replace的页面每次都在服务端重新生成；定向url提交数据

尽量避免使用split
除非是必须的，否则应该避免使用split，split由于支持正则表达式，所以效率比较低，如果是频繁的几十，几百万的调用将会耗费大量资源，如果确实需要频繁的调用split，可以考虑使用apache的StringUtils.split(string,char)，频繁split的可以缓存结果。

System.arraycopy() 要比通过循环来复制数组快的多。

只有localhost下是不区分端口共享cookie的；
同一ip（重点）访问同一域名不同端口的web，浏览器的cookie是共享的；
根据浏览器的同源策略，同域名不同端口也是跨域的


springboot项目可以直接访问static目录下的图片资源，不能直接访问static目录下的目录中的图片资源 



加密算法加密过的数据不能直接通过new String（）方法硬解码出来：
MD5, SHA-256, SHA-512 等等算法，它们是通过对byte[] 进行各种变换和运算，得到加密之后的byte[]，那么这个加密之后的 byte[] 结果显然 就不会符合任何一种的编码方案，比如 utf-8, GBK等，因为加密的过程是任意对byte[]进行运算的。所以你用任何一种编码方案来解码 加密之后的 byte[] 结果，得到的都会是乱码。
1、所以加密解密时，采用的byte[] 到 String 转换的方法都是将 byte[] 二进制利用16进制的char[]来表示，每一个 byte 是8个bit，每4个bit对应一个16进制字符。所以一个 byte 对应于两个 16进制字符（16进制的每个字符需要用4位二进制位来表示，,0x0为0000,0xf为1111，即1个16进制数为4位，0x是16进制的前缀，表过后面的常量是16进制数，0xf就是16进制的f，也就是十进制的15）；
2、用Base64编码，不过它是使用 a-z, A-Z, 0-9, /， + 这64个字符来进行编码的

算法/模式/补码方式"0102030405060708
使用CBC模式，需要一个向量iv，可增加加密算法的强度

java8的Base64的性能比apache和好；


@EnableAsync 和 @Async（“可选的线程池名”）



1、#{ }是预编译处理，MyBatis在处理#{ }时，它会将sql中的#{ }替换为？，然后调用PreparedStatement的set方法来赋值，传入字符串后，会在值两边加上单引号，如上面的值 “4,44,514”就会变成“ '4,44,514' ”；

2、${ }是字符串替换， MyBatis在处理${ }时,它会将sql中的${ }替换为变量的值，传入的数据不会加两边加上单引号。



mysql 条件查询索引使用函数处理后不是所有查询都不走索引，例如（contact函数用于like查询，可防止sql注入）
		
		
		
		
		
		